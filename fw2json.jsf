// Fireworks Extension: Command
// Create JSON from Fireworks PNG.
// version: 0.0.1
// auther: @littlebusters
// license: MIT

var console = console || {};
(function()
{
	try {
		fw.runScript( fw.userJsCommandsDir + '/Fw to JSON/i18n.fss' );
	} catch( e ) {
		fw.runScript( fw.appJsCommandsDir + '/Fw to JSON/i18n.fss' );
	}
	var d = fw.getDocumentDOM();
	var fwJSON = {"documentSetting": {"grid" : {}}, "pages": []};
	var pageSetter = d.getPageSetter();
	var bitmapCounter = 1;
	var layerType = {
		"[object RectanglePrimitive]": "rectangle",
		"[object Text]": "text",
		"[object Path]": "path",
		"[object Group]": "group",
		"[object Instance]": "symbol",
		"[object SliceHotspot]": "slice",
		"[object Layer]": "layer",
		"[object Image]": "bitmap"
	}

	fwJSON.documentSetting.grid = {"gridSize": {"x": d.gridSize.x, "y": d.gridSize.y}};
	fwJSON.documentSetting.grid.gridOrigin = {"x": d.gridOrigin.x, "y": d.gridOrigin.y};
	fwJSON.documentSetting.pageCount = d.pagesCount;
	fwJSON.documentSetting.docName = d.docTitleWithoutExtension || 'Untitled Document';

	var currentFilePath = d.filePathForSave.slice( 0, d.filePathForSave.lastIndexOf( '/' ) + 1 );
	var exportDir = fw.browseForFolderURL( 'Choose Export Folder', currentFilePath);
	if ( !exportDir ) {
		alert( 'Canceled.' );
		return false;
	}
	var filePath = exportDir + '/' + fwJSON.documentSetting.docName + '.json';
	if ( Files.exists( filePath ) ) {
		var choose = confirm( 'JSON File Exists. Delete it?' );
		if ( !choose ) {
			alert( 'Canceled.' );
			return false;
		}
	}
	var bitmapExportDirName = 'fw2json-exported-' + fwJSON.documentSetting.docName + '/'; // need /
	Files.createDirectory( exportDir + '/' + bitmapExportDirName );

	var documentLayerIndex = 0;
	for ( var pageIndex = 0; pageIndex < fwJSON.documentSetting.pageCount; pageIndex++ ) {
		pageSetter.pageNum = pageIndex;
		d = fw.getDocumentDOM();

		fwJSON.pages[pageIndex] = {};
		fwJSON.pages[pageIndex].pageName = d.pageName;
		fwJSON.pages[pageIndex].backgroundColor = d.backgroundColor;
		fwJSON.pages[pageIndex].width = d.width;
		fwJSON.pages[pageIndex].height = d.height;
		fwJSON.pages[pageIndex].guides = {"x": [], "y": []};
		for (var i = d.guides.vGuides.length - 1; i >= 0; i--) {
			fwJSON.pages[pageIndex].guides.x[i] = d.guides.vGuides[i];
		};
		for (var i = d.guides.hGuides.length - 1; i >= 0; i--) {
			fwJSON.pages[pageIndex].guides.y[i] = d.guides.hGuides[i];
		};
		fwJSON.pages[pageIndex].layers = [];

		// console.log( fwJSON.pages[pageIndex].pageName );
		fwJSON.pages[pageIndex].topLayers = getLayerAttrs( d.topLayers );
	};

	var FwJSONstr = fwJSON.toSource();
	var reg = new RegExp( /(\{)([\w_]+):|( )([\w_]+):/g );
	FwJSONstr = FwJSONstr.replace( reg, '$1$3"$2$4":');

	// Export to JSON
	if ( choose ) {
		Files.deleteFile( filePath );
	}
	fw.textOutputEncoding = 'utf-8';
	Files.createFile( filePath, '.json', '');
	var fileWrite = Files.open( filePath, true );
	fileWrite.writeUTF8( FwJSONstr );
	fileWrite.close();

	alert( 'Exported!' );



	function getLayerAttrs( _tgt ) {
		// console.log( '-> start', _tgt.length );
		var layerData = [];

		for ( var layerIndex = 0; layerIndex < _tgt.length; layerIndex++ ) {
			layerData[layerIndex] = {};
			layerData[layerIndex].name = _tgt[layerIndex].name;
			layerData[layerIndex].type = layerType[_tgt[layerIndex].toString()];
			layerData[layerIndex].parentLayerNum = d.getParentLayerNum( documentLayerIndex++ );

			// console.log( layerData[layerIndex].name );
			if ( _tgt[layerIndex].elems.length ) {
				layerData[layerIndex].elems = getElemAttrs( _tgt[layerIndex].elems );
				layerData[layerIndex].hasChildren = true;
			} else {
				layerData[layerIndex].hasChildren = false;
			}
		}

		return layerData;
	}

	function getChildLayerAttrs( _tgt ) {
		console.log( '-> start' );
		var layerData = {};

		layerData.name = _tgt.name;
		layerData.type = layerType[_tgt.toString()];
		layerData.parentLayerNum = d.getParentLayerNum( documentLayerIndex++ );

		console.log( layerData.name );
		if ( _tgt.elems.length ) {
			layerData.elems = getElemAttrs( _tgt.elems );
			layerData.hasChildren = true;
		} else {
			layerData.hasChildren = false;
		}

		return layerData;
	}

	function getElemAttrs( _tgt ) {
		// console.log( '-> start' );
		var elemData = [];

		for ( var childIndex = 0, elemIndex = 0 ; childIndex < _tgt.length; childIndex++ ) {
			// console.log( _tgt[childIndex].toString(), _tgt[childIndex].name, childIndex );
			if ( '[object Layer]' != _tgt[childIndex].toString() ) {
				elemData[elemIndex] = {};
				elemData[elemIndex].type = layerType[_tgt[childIndex].toString()];
				elemData[elemIndex].name = _tgt[childIndex].name || elemData[elemIndex].type;
				elemData[elemIndex].width = _tgt[childIndex].width;
				elemData[elemIndex].height = _tgt[childIndex].height;
				elemData[elemIndex].top = _tgt[childIndex].top;
				elemData[elemIndex].left = _tgt[childIndex].left;
				elemData[elemIndex].blendMode = _tgt[childIndex].blendMode;
				elemData[elemIndex].opacity = _tgt[childIndex].opacity;
				elemData[elemIndex].visible = _tgt[childIndex].visible;
				// console.log( elemData[elemIndex].name, elemData[elemIndex].type, '/ gat basics--' );

				if ( 'group' != elemData[elemIndex].type 
					&& 'symbol' != elemData[elemIndex].type
					&& 'bitmap' != elemData[elemIndex].type
					&& 'slice' != elemData[elemIndex].type  ) {
					if ( null != _tgt[childIndex].pathAttributes.fill ) {
						elemData[elemIndex].fill = getFillAttrs( _tgt[childIndex] );
					}
					if ( null != _tgt[childIndex].pathAttributes.brush ) {
						elemData[elemIndex].border = getBorderAttrs( _tgt[childIndex].pathAttributes );
					}
				} else if ( 'slice' == elemData[elemIndex].type ) {
					elemData[elemIndex].baseName = _tgt[childIndex].baseName || elemData[elemIndex].type;
					if ( null == _tgt[childIndex].exportOptions ) {
						elemData[elemIndex].exportOptions = getExportOptions( d.exportOptions );
					} else {
						elemData[elemIndex].exportOptions = getExportOptions( _tgt[childIndex].exportOptions );
					}
				}
				if ( 'rectangle' == elemData[elemIndex].type ) {
					elemData[elemIndex] = getRectangleAttrs( _tgt[childIndex], elemData[elemIndex] );
				}
				if ( 'path' == elemData[elemIndex].type ) {
					elemData[elemIndex].bezierPath = getPathNodes( _tgt[childIndex].contours );
				}
				if ( 'text' == elemData[elemIndex].type ) {
					elemData[elemIndex].text = getTextAttrs( _tgt[childIndex].textRuns );
					elemData[elemIndex].text.autoKern = _tgt[childIndex].autoKern;
				}
				if ( null != _tgt[childIndex].mask && _tgt[childIndex].mask.enabled ) {
					elemData[elemIndex].mask = getMaskAttrs( _tgt[childIndex].mask );
				}
				if ( 'symbol' == elemData[elemIndex].type ) {
					fw.selection = _tgt[childIndex];
					d.detachInstanceFromSymbol();
					var sel = fw.selection[0];
					elemData[elemIndex].elements = getElemAttrs( sel.elements );
				}
				if ( 'bitmap' == elemData[elemIndex].type ) {
					elemData[elemIndex].uri = exportBitmap( _tgt[childIndex] );
					// console.log( elemData[elemIndex].uri );
				}
				if ( 'group' == elemData[elemIndex].type ) {
					elemData[elemIndex].elements = getElemAttrs( _tgt[childIndex].elements );
				}
				if ( null != _tgt[childIndex].effectList && 0 != _tgt[childIndex].effectList.length ) {
					elemData[elemIndex].effectList = getEffect( _tgt[childIndex].effectList );
					// console.log( elemData[elemIndex].effectList );
				}
				elemIndex++;
			} else {
				console.log( _tgt[childIndex].name );
				elemData[elemIndex] = getChildLayerAttrs( _tgt[childIndex] );
				elemIndex++;
				console.log( 'get Layer F' );
			}
		}
		// console.log( elemData );

		return elemData;
	}

	function getEffect( _attrs ) {
		var effects = {};
		effects = ( new Function( 'return ' + _attrs.javascriptString ) )();

		return effects;
	}

	function exportBitmap( _tgt ) {
		fw.selection = _tgt;
		var objectName = ( _tgt.name ) ? _tgt.name + bitmapCounter++ : 'unnamedObject' + bitmapCounter++;
		var savePath = exportDir + '/' + bitmapExportDirName + objectName + '.png';

		d.clipCopy();
		fw.createDocument();
		fw.getDocumentDOM().clipPaste( 'do not resample' );
		fw.getDocumentDOM().backgroundColor = '#ffffff00';
		fw.saveDocument( null, savePath );
		fw.getDocumentDOM().close( false );

		return savePath;
	}

	function getMaskAttrs( _attrs ) {
		var attrs = {};

		attrs.mode = _attrs.mode;
		var elems = [_attrs.element];
		attrs.element = getElemAttrs( elems );

		return attrs;
	}

	function getRectangleAttrs( _attrs, _origin ) {
		_origin.transform = { "matrix": []};
		for ( var i = _attrs.transform.matrix.length - 1; i >= 0; i-- ) {
			_origin.transform.matrix[i] = _attrs.transform.matrix[i];
		};

		_origin.originalSides = {};
		_origin.originalSides['left']   = _attrs.originalSides.left;
		_origin.originalSides['right']  = _attrs.originalSides.right;
		_origin.originalSides['top']    = _attrs.originalSides.top;
		_origin.originalSides['bottom'] = _attrs.originalSides.bottom;

		_origin.radius = _attrs.roundness;

		return _origin;
	}

	function getTextAttrs( _tgt ) {
		// console.log( '-> start' );
		var attrs = {};

		attrs.fontFace = _tgt.initialAttrs.face;
		attrs.fontSize = _tgt.initialAttrs.size.slice( 0, -2 );
		attrs.alignment = _tgt.initialAttrs.alignment;
		attrs.underline = _tgt.initialAttrs.underline;
		attrs.fillColor = _tgt.initialAttrs.fillColor;
		attrs.baselineShift = _tgt.initialAttrs.baselineShift;
		if ( 'percentage' == _tgt.initialAttrs.leadingMode ) {
			attrs.leading = attrs.fontSize * floorWithDigit( _tgt.initialAttrs.leading, 2 );
		} else {
			attrs.leading = _tgt.initialAttrs.leading;
		}

		attrs.textRuns = [];
		if ( null != _tgt.textRuns ) {
			for ( var i = _tgt.textRuns.length - 1; i >= 0; i-- ) {
				attrs.textRuns[i] = {};
				attrs.textRuns[i].characters = _tgt.textRuns[i].characters;
				attrs.textRuns[i].characters = attrs.textRuns[i].characters.replace( '\n', '\n' );
				attrs.textRuns[i].characters = attrs.textRuns[i].characters.replace( '\r', '\r' );
				attrs.textRuns[i].characters = attrs.textRuns[i].characters.replace( '\t', '\t' );
				attrs.textRuns[i].size = _tgt.textRuns[i].changedAttrs.size.slice( 0, -2 );
				attrs.textRuns[i].face = _tgt.textRuns[i].changedAttrs.face;
				attrs.textRuns[i].underline = _tgt.textRuns[i].changedAttrs.underline;
				attrs.textRuns[i].fillColor = _tgt.textRuns[i].changedAttrs.fillColor;
				attrs.textRuns[i].baselineShift = _tgt.textRuns[i].changedAttrs.baselineShift;
				if ( 'percentage' == _tgt.textRuns[i].changedAttrs.leadingMode ) {
					attrs.textRuns[i].leading = attrs.textRuns[i].size * floorWithDigit( _tgt.textRuns[i].changedAttrs.leading, 2 );
				} else {
					attrs.textRuns[i].leading = _tgt.initialAttrs.leading;
				}
			};
		}
		
		return attrs;
	}
	//getTextAttrs( sel[0].textRuns );

	function getPathNodes( _tgt ) {
		// console.log( '-> start' );
		var attrs = [];

		for ( var i = _tgt.length - 1; i >= 0; i-- ) {
			attrs[i] = {};
			attrs[i].isClosed = _tgt[i].isClosed;
			attrs[i].nodes = [];
			for ( var j = _tgt[i].nodes.length - 1; j >= 0; j-- ) {
				attrs[i].nodes[j] = { "isCurvePoint": _tgt[i].nodes[j].isCurvePoint };
				attrs[i].nodes[j].ancherPointX = _tgt[i].nodes[j].x;
				attrs[i].nodes[j].ancherPointY = _tgt[i].nodes[j].y;
				attrs[i].nodes[j].succPointX = _tgt[i].nodes[j].succX;
				attrs[i].nodes[j].succPointY = _tgt[i].nodes[j].succY;
				attrs[i].nodes[j].predPointX = _tgt[i].nodes[j].predX;
				attrs[i].nodes[j].predPointY = _tgt[i].nodes[j].predY;
			};
		};

		return attrs;
	}
	//getPathNodes( sel[0].contours );

	function getExportOptions( _tgt ) {
		// console.log( '-> start' );
		var attrs = {};

		attrs.exportFormat = _tgt.exportFormat;
		attrs.jpegQuality = _tgt.jpegQuality;

		return attrs;
	}

	function getFillAttrs( _tgt ) {
		// console.log( '-> start' );
		var elemData = {};
		var tgt = _tgt.pathAttributes;

		elemData.fillColor = tgt.fillColor;
		elemData.feather = tgt.fill.feather;
		elemData.fillType = 'flat';
		if ( null != tgt.fill.gradient ) {
			elemData.gradient = getGradientAtts( tgt );
			elemData.fillType = 'gradient';
		}
		if ( null != tgt.fill.pattern ) {
			elemData.pattern = exportBitmap( _tgt );
			elemData.fillType = 'pattern';
		}

		return elemData;
	}

	function getGradientAtts( _tgt ) {
		// console.log( '-> start' );
		var elemData = {};

		elemData.gradientType = _tgt.fill.shape;
		elemData.gradientPoint = [{}, {}, {}];
		elemData.gradientPoint[0].x = _tgt.fillHandle1.x;
		elemData.gradientPoint[0].y = _tgt.fillHandle1.y;
		elemData.gradientPoint[1].x = _tgt.fillHandle2.x;
		elemData.gradientPoint[1].y = _tgt.fillHandle2.y;
		elemData.gradientPoint[2].x = _tgt.fillHandle3.x;
		elemData.gradientPoint[2].y = _tgt.fillHandle3.y;

		elemData.gradientNodes = getGradientStops( _tgt.fill.gradient );

		return elemData;
	}

	function getGradientStops( _tgt ) {
		// console.log( '-> start' );
		var gradientNodes = {"nodes":[], "opacityNodes":[]}

		for ( var i = _tgt.nodes.length - 1; i >= 0; i-- ) {
			gradientNodes.nodes.push( {
				"isOpacityNode": _tgt.nodes[i].isOpacityNode,
				"position": _tgt.nodes[i].position,
				"color": _tgt.nodes[i].color
			} );
		};
		for ( var i = _tgt.opacityNodes.length - 1; i >= 0; i-- ) {
			gradientNodes.opacityNodes.push( {
				"isOpacityNode": _tgt.opacityNodes[i].isOpacityNode,
				"position": _tgt.opacityNodes[i].position,
				"color": _tgt.opacityNodes[i].color
			} );
		};

		return gradientNodes;
	}
	// getGradientStops( sel[0].pathAttributes.fill.gradient );

	function getBorderAttrs( _tgt ) {
		// console.log( '-> start' );
		var borderAttrs = {};

		if ( 9 == _tgt.brushColor.length ) {
			borderAttrs.color = _tgt.brushColor.slice( 0, 7 );
			borderAttrs.opacity = getOpacityByDigit( _tgt.brushColor.slice( 7, 9 ) );
		} else {
			borderAttrs.color = _tgt.brushColor;
			borderAttrs.opacity = 1
		}
		borderAttrs.dashType = _tgt.brush.numDashes;
		borderAttrs.dashAttr = [];
		borderAttrs.dashAttr.push( {"dash": _tgt.brush.dashOnSize1, "gap": _tgt.brush.dashOffSize1} );
		borderAttrs.dashAttr.push( {"dash": _tgt.brush.dashOnSize2, "gap": _tgt.brush.dashOffSize2} );
		borderAttrs.dashAttr.push( {"dash": _tgt.brush.dashOnSize3, "gap": _tgt.brush.dashOffSize3} );
		borderAttrs.edge = _tgt.brush.shape;
		borderAttrs.position = _tgt.brushPlacement;
		borderAttrs.thickness = _tgt.brush.diameter;

		return borderAttrs;
	}
	// getBorderAttrs( sel[0].pathAttributes );

	function floorWithDigit ( _val, _digit ) {
		var digit = Math.pow( 10, _digit );
		var val = _val * digit;

		return Math.floor( val ) / digit;
	}
	// floorWithDigit( 3.14567, 2 );
	function getOpacityByDigit ( _hex ) {
		var digit = ( parseInt( '0x' + _hex ).toString( 10 ) ) / 255;

		return floorWithDigit( digit, 2 );
	}
	function digit2Hex ( _digit ) {
		var hex = parseInt( _digit ).toString( 16 );
		if ( 1 == hex.length ) hex = '0' + hex;
		return hex;
	}
	function hex2Digit ( _hex ) {
		return ( parseInt( '0x' + _hex ).toString( 10 ) );
	}
	// getOpacityByDigit( 80 );

})();